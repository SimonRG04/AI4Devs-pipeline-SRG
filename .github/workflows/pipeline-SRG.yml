name: CI/CD Pipeline SRG

# Este pipeline se activa cuando se hace push a una rama que tiene un Pull Request abierto
# Actualización: Agregado comentario para probar el trigger del workflow
on:
  push:
    branches:
      - '**'  # Cualquier rama
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  # Trabajo para verificar si la rama tiene un PR abierto
  check_pr:
    runs-on: ubuntu-latest
    outputs:
      has_pr: ${{ steps.check_pr.outputs.has_pr }}
    steps:
      - name: Check if branch has open PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = context.ref.replace('refs/heads/', '');
            
            // Buscar PRs abiertos para esta rama
            const pulls = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`
            });
            
            const hasPR = pulls.data.length > 0;
            console.log(`Branch ${branch} has open PR: ${hasPR}`);
            return core.setOutput('has_pr', hasPR.toString());

  # Job de test que solo se ejecuta si hay un PR abierto
  test:
    needs: check_pr
    if: needs.check_pr.outputs.has_pr == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      # Instalar dependencias del backend
      - name: Install dependencies
        working-directory: backend
        run: npm ci
      
      # Generar cliente Prisma para los tests
      - name: Generate Prisma client
        working-directory: backend
        run: npm run prisma:generate
      
      # Ejecutar los tests
      # Este paso ejecuta todas las pruebas configuradas en Jest para validar el funcionamiento correcto del código
      - name: Run tests
        working-directory: backend
        run: npm run test
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL || 'postgresql://test:test@localhost:5432/testdb' }}

  # Job de build que solo se ejecuta si los tests pasan
  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      # Instalar dependencias
      - name: Install dependencies
        working-directory: backend
        run: npm ci
      
      # Generar cliente Prisma para la build
      - name: Generate Prisma client
        working-directory: backend
        run: npm run prisma:generate
      
      # Compilar el código TypeScript a JavaScript
      # Este paso transpila el código TS a JS que puede ser ejecutado en producción
      - name: Build backend
        working-directory: backend
        run: npm run build
      
      # Crear un archivo comprimido con todo lo necesario para el despliegue
      # Este paso empaqueta el código compilado, archivos de configuración y dependencias
      - name: Create deployment package
        working-directory: backend
        run: |
          mkdir -p deployment
          cp -r dist prisma package.json package-lock.json deployment/
          cd deployment
          echo "NODE_ENV=production" > .env
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env
          cd ..
          tar -czf backend-deployment.tar.gz deployment
      
      # Guardar el artefacto para usar en el paso de despliegue
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend/backend-deployment.tar.gz
          retention-days: 1

  # Job de despliegue que solo se ejecuta si el build es exitoso
  deploy:
    needs: build
    runs-on: ubuntu-latest
    # Especificar el entorno donde están configurados los secrets
    environment: Testing
    
    # Validamos que el PR esté abierto
    if: needs.check_pr.outputs.has_pr == 'true'
    
    steps:
      - name: Verify required secrets
        id: check_secrets
        run: |
          missing_secrets=()
          
          # Verificar que existan todos los secrets necesarios para el despliegue
          [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && missing_secrets+=("AWS_ACCESS_KEY_ID")
          [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] && missing_secrets+=("AWS_SECRET_ACCESS_KEY")
          [ -z "${{ secrets.AWS_REGION }}" ] && missing_secrets+=("AWS_REGION")
          [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ] && missing_secrets+=("EC2_SSH_PRIVATE_KEY")
          [ -z "${{ secrets.EC2_HOST }}" ] && missing_secrets+=("EC2_HOST")
          [ -z "${{ secrets.EC2_USER }}" ] && missing_secrets+=("EC2_USER")
          [ -z "${{ secrets.DATABASE_URL }}" ] && missing_secrets+=("DATABASE_URL")
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Los siguientes secrets son necesarios pero no están definidos:"
            printf "  - %s\n" "${missing_secrets[@]}"
            exit 1
          fi
          
          echo "Todos los secrets necesarios están configurados"
      
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-build
      
      # Configurar las credenciales de AWS
      # Este paso establece las credenciales necesarias para interactuar con AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      # Verificar la conexión a AWS
      - name: Verify AWS Connection
        run: |
          echo "Verificando conexión a AWS..."
          # Verificar que las credenciales de AWS funcionan correctamente
          aws sts get-caller-identity
          if [ $? -ne 0 ]; then
            echo "Error: No se pudo establecer conexión con AWS. Verifica las credenciales."
            exit 1
          fi
          echo "Conexión a AWS establecida correctamente."
      
      # Configurar SSH para conectarse a la instancia EC2
      # Este paso prepara la autenticación SSH para la conexión segura a la instancia
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
      
      # Verificar la conexión SSH
      - name: Verify SSH Connection
        run: |
          echo "Verificando conexión SSH a la instancia EC2..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'Conexión SSH establecida correctamente'"
          if [ $? -ne 0 ]; then
            echo "Error: No se pudo establecer conexión SSH con la instancia. Verifica la clave SSH y los datos de la instancia."
            exit 1
          fi
      
      # Transferir los archivos a la instancia EC2
      # Este paso envía el paquete de despliegue a la instancia de EC2 
      - name: Transfer files to EC2
        run: |
          echo "Transfiriendo archivos a la instancia EC2..."
          scp -o StrictHostKeyChecking=no backend-deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
          if [ $? -ne 0 ]; then
            echo "Error: No se pudieron transferir los archivos a la instancia EC2."
            exit 1
          fi
          echo "Archivos transferidos correctamente."
      
      # Ejecutar comandos de despliegue en la instancia EC2
      # Este paso despliega la aplicación en el servidor, descomprimiendo los archivos,
      # instalando dependencias y reiniciando el servicio
      - name: Deploy to EC2
        run: |
          echo "Iniciando despliegue en la instancia EC2..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e  # Detener en caso de error
            
            echo "Deteniendo el servicio actual..."
            # Detener el servicio actual si existe
            if systemctl is-active --quiet backend-service; then
              sudo systemctl stop backend-service || echo "No se pudo detener el servicio, pero continuamos"
            else
              echo "El servicio no está actualmente en ejecución"
            fi
            
            echo "Limpiando directorio anterior..."
            # Limpiar directorio anterior si existe
            sudo rm -rf /opt/backend
            sudo mkdir -p /opt/backend
            
            echo "Descomprimiendo el nuevo paquete..."
            # Descomprimir el nuevo paquete
            if [ ! -f /tmp/backend-deployment.tar.gz ]; then
              echo "Error: El archivo de despliegue no existe en /tmp/"
              exit 1
            fi
            
            sudo tar -xzf /tmp/backend-deployment.tar.gz -C /opt/ || { echo "Error al descomprimir"; exit 1; }
            sudo mv /opt/deployment/* /opt/backend/ || { echo "Error al mover archivos"; exit 1; }
            sudo rm -rf /opt/deployment
            sudo rm /tmp/backend-deployment.tar.gz
            
            echo "Configurando permisos..."
            # Configurar permisos
            sudo chown -R $USER:$USER /opt/backend
            
            echo "Instalando dependencias de producción..."
            # Instalar dependencias de producción
            cd /opt/backend
            npm ci --only=production
            
            echo "Configurando el servicio systemd..."
            # Crear o actualizar el servicio systemd
            sudo tee /etc/systemd/system/backend-service.service > /dev/null << 'EOT'
            [Unit]
            Description=Backend API Service
            After=network.target
            
            [Service]
            Type=simple
            User=$USER
            WorkingDirectory=/opt/backend
            ExecStart=/usr/bin/npm start
            Restart=on-failure
            Environment=NODE_ENV=production
            
            [Install]
            WantedBy=multi-user.target
            EOT
            
            echo "Recargando configuración de systemd..."
            # Recargar configuración systemd y reiniciar el servicio
            sudo systemctl daemon-reload
            sudo systemctl enable backend-service
            
            echo "Iniciando el servicio..."
            sudo systemctl start backend-service
            
            echo "Verificando estado del servicio..."
            # Verificar estado del servicio
            sudo systemctl status backend-service --no-pager
            
            # Verificar que el servicio está realmente en ejecución
            if ! systemctl is-active --quiet backend-service; then
              echo "ERROR: El servicio no se inició correctamente"
              exit 1
            else
              echo "Servicio desplegado y en ejecución correctamente"
            fi
          EOF
          
          if [ $? -ne 0 ]; then
            echo "Error durante el despliegue en la instancia EC2."
            exit 1
          fi
          
          echo "¡Despliegue completado con éxito!" 