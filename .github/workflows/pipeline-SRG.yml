name: CI/CD Pipeline SRG

# Este pipeline se activa cuando se hace push a una rama que tiene un Pull Request abierto
# Actualización: Agregado comentario para probar el trigger del workflow
on:
  push:
    branches:
      - '**'  # Cualquier rama
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  # Trabajo para verificar si la rama tiene un PR abierto
  check_pr:
    runs-on: ubuntu-latest
    outputs:
      has_pr: ${{ steps.check_pr.outputs.has_pr }}
    steps:
      - name: Check if branch has open PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = context.ref.replace('refs/heads/', '');
            
            // Buscar PRs abiertos para esta rama
            const pulls = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`
            });
            
            const hasPR = pulls.data.length > 0;
            console.log(`Branch ${branch} has open PR: ${hasPR}`);
            return core.setOutput('has_pr', hasPR.toString());

  # Job de test que solo se ejecuta si hay un PR abierto
  test:
    needs: check_pr
    if: needs.check_pr.outputs.has_pr == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      # Instalar dependencias del backend
      - name: Install dependencies
        working-directory: backend
        run: npm ci
      
      # Generar cliente Prisma para los tests
      - name: Generate Prisma client
        working-directory: backend
        run: npm run prisma:generate
      
      # Ejecutar los tests
      # Este paso ejecuta todas las pruebas configuradas en Jest para validar el funcionamiento correcto del código
      - name: Run tests
        working-directory: backend
        run: npm run test
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL || 'postgresql://test:test@localhost:5432/testdb' }}

  # Job de build que solo se ejecuta si los tests pasan
  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      # Instalar dependencias
      - name: Install dependencies
        working-directory: backend
        run: npm ci
      
      # Generar cliente Prisma para la build
      - name: Generate Prisma client
        working-directory: backend
        run: npm run prisma:generate
      
      # Compilar el código TypeScript a JavaScript
      # Este paso transpila el código TS a JS que puede ser ejecutado en producción
      - name: Build backend
        working-directory: backend
        run: npm run build
      
      # Crear un archivo comprimido con todo lo necesario para el despliegue
      # Este paso empaqueta el código compilado, archivos de configuración y dependencias
      - name: Create deployment package
        working-directory: backend
        run: |
          mkdir -p deployment
          cp -r dist prisma package.json package-lock.json deployment/
          cd deployment
          echo "NODE_ENV=production" > .env
          echo "DATABASE_URL=postgresql://test:test@localhost:5432/testdb" >> .env
          cd ..
          tar -czf backend-deployment.tar.gz deployment
      
      # Guardar el artefacto para usar en el paso de despliegue
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend/backend-deployment.tar.gz
          retention-days: 1

  # Job de despliegue que solo se ejecuta si el build es exitoso
  deploy:
    needs: build
    runs-on: ubuntu-latest
    # Especificar el entorno donde están configurados los secrets
    environment: Testing
    
    # Validamos que el PR esté abierto
    if: needs.check_pr.outputs.has_pr == 'true'
    
    steps:
      - name: Verify required secrets
        id: check_secrets
        run: |
          missing_secrets=()
          
          # Verificar solo los secrets de EC2 que son esenciales
          [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ] && missing_secrets+=("EC2_SSH_PRIVATE_KEY")
          [ -z "${{ secrets.EC2_HOST }}" ] && missing_secrets+=("EC2_HOST")
          [ -z "${{ secrets.EC2_USER }}" ] && missing_secrets+=("EC2_USER")
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: Los siguientes secrets son necesarios pero no están definidos:"
            printf "  - %s\n" "${missing_secrets[@]}"
            exit 1
          fi
          
          echo "Todos los secrets necesarios para SSH están configurados"
      
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-build
      
      # Diagnóstico de red para verificar conectividad
      - name: Network diagnostics
        run: |
          echo "Diagnóstico de red:"
          echo "Verificando resolución DNS..."
          nslookup ${{ secrets.EC2_HOST }} || echo "Error en resolución DNS para el host EC2"
          
          echo "Verificando conectividad..."
          ping -c 4 ${{ secrets.EC2_HOST }} || echo "Error en conectividad a EC2"
      
      # Extraer la clave pública a partir de la privada para verificación
      - name: Extract public key from private key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Generar y mostrar la clave pública correspondiente
          ssh-keygen -y -f ~/.ssh/id_rsa || { 
            echo "ERROR: No se pudo generar la clave pública. Verificar formato de la clave privada"; 
            echo "Primeras líneas de la clave privada:";
            head -n 2 ~/.ssh/id_rsa | cat -A;
            exit 1; 
          }
          
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
          
          echo "=========================================================="
          echo "ATENCIÓN: Para que la conexión SSH funcione correctamente,"
          echo "esta clave pública debe estar en el archivo authorized_keys"
          echo "del usuario ${{ secrets.EC2_USER }} en la instancia EC2:"
          echo "=========================================================="
          cat ~/.ssh/id_rsa.pub
          echo "=========================================================="
          echo "Comando para añadir esta clave en la instancia EC2:"
          echo "echo '$(cat ~/.ssh/id_rsa.pub)' >> ~/.ssh/authorized_keys"
          echo "=========================================================="
      
      # Intentar conexión con claves explícitas y verificación exhaustiva
      - name: Test SSH connection
        run: |
          # Configurar SSH con mayor nivel de debug
          echo "LogLevel DEBUG3" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # Probar conexión con verbose y timeout extendido
          ssh -vvv -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'Prueba de conexión'" || {
            echo "ERROR: Fallo de conexión SSH"
            echo "Verificando formato de la clave:"
            file ~/.ssh/id_rsa
            echo "Verificando permisos:"
            ls -la ~/.ssh/
            echo "Continuamos con método alternativo"
          }
      
      # Usar acción SSH dedicada como alternativa
      - name: Desplegar con SSH Action
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          port: 22
          command_timeout: 60m
          debug: true
          script: |
            echo "Conexión SSH establecida correctamente desde la acción SSH"
            echo "Verificando sistema:"
            uname -a
            echo "Usuario actual:"
            whoami
            echo "Directorio actual:"
            pwd
      
      # Transferir archivos usando scp-action
      - name: SCP files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          port: 22
          debug: true
          source: "backend-deployment.tar.gz"
          target: "/tmp"
          
      # Desplegar usando la acción SSH
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          port: 22
          command_timeout: 60m
          debug: true
          script: |
            set -e  # Detener en caso de error
            
            echo "Deteniendo el servicio actual..."
            # Detener el servicio actual si existe
            if systemctl is-active --quiet backend-service; then
              sudo systemctl stop backend-service || echo "No se pudo detener el servicio, pero continuamos"
            else
              echo "El servicio no está actualmente en ejecución"
            fi
            
            echo "Limpiando directorio anterior..."
            # Limpiar directorio anterior si existe
            sudo rm -rf /opt/backend
            sudo mkdir -p /opt/backend
            
            echo "Descomprimiendo el nuevo paquete..."
            # Descomprimir el nuevo paquete
            if [ ! -f /tmp/backend-deployment.tar.gz ]; then
              echo "Error: El archivo de despliegue no existe en /tmp/"
              exit 1
            fi
            
            sudo tar -xzf /tmp/backend-deployment.tar.gz -C /opt/ || { echo "Error al descomprimir"; exit 1; }
            sudo mv /opt/deployment/* /opt/backend/ || { echo "Error al mover archivos"; exit 1; }
            sudo rm -rf /opt/deployment
            sudo rm /tmp/backend-deployment.tar.gz
            
            echo "Configurando permisos..."
            # Configurar permisos
            sudo chown -R $USER:$USER /opt/backend
            
            echo "Instalando dependencias de producción..."
            # Instalar dependencias de producción
            cd /opt/backend
            npm ci --only=production
            
            echo "Configurando el servicio systemd..."
            # Crear o actualizar el servicio systemd
            sudo tee /etc/systemd/system/backend-service.service > /dev/null << 'EOT'
            [Unit]
            Description=Backend API Service
            After=network.target
            
            [Service]
            Type=simple
            User=$USER
            WorkingDirectory=/opt/backend
            ExecStart=/usr/bin/npm start
            Restart=on-failure
            Environment=NODE_ENV=production
            
            [Install]
            WantedBy=multi-user.target
            EOT
            
            echo "Recargando configuración de systemd..."
            # Recargar configuración systemd y reiniciar el servicio
            sudo systemctl daemon-reload
            sudo systemctl enable backend-service
            
            echo "Iniciando el servicio..."
            sudo systemctl start backend-service
            
            echo "Verificando estado del servicio..."
            # Verificar estado del servicio
            sudo systemctl status backend-service --no-pager
            
            # Verificar que el servicio está realmente en ejecución
            if ! systemctl is-active --quiet backend-service; then
              echo "ERROR: El servicio no se inició correctamente"
              exit 1
            else
              echo "Servicio desplegado y en ejecución correctamente"
            fi 